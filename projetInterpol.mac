/*
Fichier rassemblant toutes les fonctions de notre projet afin d'eviter de multiplier les imports
Auteurs : Robin Trioux, William Veal Phan
Date de création : 10/12/2016
*/




/* ------------ HELP ----------------*/



helpInterpol():=block
(
	print("Fonctions incluses dans le projet : "),
	print("reglist(a,b,n) : construit une liste reguliere de n+1 points entre a et b"),
	print("tchebylist(a,b,n) : genere une distribution de Tchebychev de n+1 points entre a et b"),
	print("Pour les fonction dinterpolation, il faut utiliser la fonction define afin de recuperer une fonction et non une expression."),
	print("Dans la suite, on considerera des distribution de points modelises par une list d'abscisses et une liste d'ordonnees."),
	print("Lagrange(x,Lx,Ly) : x une variable muette, renvois une interpolation de Lagrange."),
	print("PedagoLagrange(x,Lx,Ly) : version imagee de Lagrange"),
	print("L hermite"),
	print("moindresCarres(Lx,Ly,d) : interpolle uen série de points par un polynome de degré au plus d minimisant l'erreur quadrqtique"),
	print("interpFourier(Lx,Ly) : interpolation par un polynome trigonometrique"),
	print("errQuadContinue(u,v,a,b) : donne l'erreur dans la norme L²(a,b) entre 2 fonctions u et v"),
	print("errQuadDiscrete(u,v,Lx) : donne la somme du carre des erreurs entre u et v pour les abscisses Lx. On preferera utiliser cette fonction plutot que la precedente pour le calcul sous Maxima dans le cas ou le nomre de points a interpoler est trop important. "),
	""
)$

/*ATTENTION: Pour pouvoir être utilisée comme une fonction dans maxima,
	     il est nécessaire d'utiliser un define.
	     Par exemple pour Lagrange il est nécessaire de déclarer une fonction de la façon suivante:

	 _____________________________________________
	|                                             |
	|	define(f(x),Lagrange(xi,yi))$         |
	|_____________________________________________|		

*/




/* ---------------------- DISTRIBUTIONS----------------------------*/




/* contruit N+1 points x0 ... xn*/
/* Distribution régulière*/
reglist(a,b,n):=block 
(
	l:[],	
	for i:0 thru n step 1 do
	(
		l:endcons(a+i*(b-a)/n,l)
	),
	l
)$

/* Distribution Tchebychev*/
tchebylist(a,b,n):=block
(
	l:[],
	for i:0 thru n step 1 do
	(
		l:endcons((a+b)/2-(b-a)/2*cos((i+1/2)*%pi/(n+1)),l)
	),
	l
)$



/* ------------- LAGRANGE -------------------------------- */


/* xi et yi sont deux listes de même dimension=n*/

Lagrange(xi,yi):=block 
(
	kill(x), /*On s'assure que x sera bien traitée */
	n:length(xi)-1,
	L:0,
	for i:1 thru n+1 step 1 do 
	(
		Li:1,
		for j:1 thru n+1 step 1 do
		(
			if(is(notequal(i,j))) /* ~ not(i=j)*/
			then (Li:Li*(x-xi[j])/(xi[i]-xi[j]))
		),
		L:yi[i]*Li+L
	),	
	define(F_L(x),L),
	F_L(x)
);



PedagoLagrange(xi,yi):=block
(
	kill(x),
	n:length(xi)-1,
	L:0,
	Li:[],
	for i:1 thru n+1 step 1 do 
	(
		Li:endcons(1,Li),
		for j:1 thru n+1 step 1 do
		(
			if(is(notequal(i,j))) /* ~ not(i=j)*/
			then (Li[i]:Li[i]*(x-xi[j])/(xi[i]-xi[j]))
		),
		L:yi[i]*Li[i]+L,
		print('"L"[i],"= ",Li[i])
	),
	print("Polynome de Lagrange ",L),
	define(F_L(x),L),
	FListTemp:makelist(yi[i]*Li[i],i,1,n+1),
	FList:append([[discrete,xi,yi]],[L],FListTemp),
	DiscreteStyle:[style,[points,2,1,1]],
	FonctionStyle:makelist([lines,2,i],i,2,n+3),
	StyleList:append(DiscreteStyle,FonctionStyle),
	LegendList:append([legend,"Donnees d'interpolation","L(x)"],makelist(string(sconcat("y",i,".L",i,"(x)")),i,1,n+1)),



	
	xmin:apply(min,xi),
	xmax:apply(max,xi),
	ymin:apply(min,yi),
	ymax:apply(max,yi),
	/*On élargi un peu les bornes pour l'affichage*/
	k: 0.2*(xmax-xmin),
	xmax:xmax+k/2,
	xmin:xmin-k/2,
	k: 0.2*(ymax-ymin),
	ymax:ymax+k/2,
	ymin:ymin-k/2,
		
	plot2d(FList,[x,xmin,xmax],[y,ymin,ymax],StyleList,LegendList),
	kill(FListTemp,xmin,xmax,ymin,ymax),
	F_L(x)
);




/* ----------------------- HERMITE ---------------------- */


Hermite(xi,yi):=block
(

	kill(x),
	n:length(xi),
	H:0,
	for i:1 thru n step 1 do 
	(
		Li:1,
		for j:1 thru n step 1 do
		(
			if(is(notequal(i,j)))
			then (Li:Li*((x-xi[j])/(xi[i]-xi[j])))
		),
		qi:Li^2,
		define(F_qi(x),qi),/*Ce bloc sert uniquement à rendre plus lisible l'expression de H 11 lignes plus bas*/
		define(F_Li(x),Li),
		define(F_dLi(x),diff(Li,x)),
		Hi:qi*(1-2*F_dLi(xi[i])*(x-xi[i])),
		Ki:qi*(x-xi[i]),

		if((i<(n)) and i#1 ) /*On ne peut pas dériver sur les extremités */
		then
		(
			/*DeltaY est le taux de variation de y soit une approximation de f'(xi) ici nous faisons la moyenne des deux variations à droite et à gauche d'un point*/
			DeltaY:((yi[i+1]-yi[i])/(xi[i+1]-xi[i])+(yi[i]-yi[i-1])/(xi[i]-xi[i-1]))/2,
			
			H:H+(yi[i]*Hi+DeltaY*Ki) /*Si pour une raison ou une autre nous connaissons f'(xi), il serait alors préférable de remplacer DeltaY par cette grandeur*/
		)
		
	),
	define(F_H(x),H),
	F_H(x)
);



/* ----------------------- MOINDRES CARRES ---------------- */




/*
Fonction generant un polynome d'interpolation suivant la methode des moindres carres
Arguments :
Lx : une liste d'abscisses
Ly : la liste des ordonnees correspondantes
p : le degre souhaite du polynome d'interpolation, p < n
Resultat :
P(x) : le polynome d'interpolation
*/

moindresCarres(Lx,Ly,d):=block
(
	kill(x,Px), /* si x est asttribué a une autre valeur la fonction bug. Faute d'avoir une meilleur solution, on kill x a chaque fois */
	n : length(Lx),
	Xm:zeromatrix(n,d+1),
	for k:1 thru n do
	(
		for j:1 thru d+1 do
		(
			if (j=1) then Xm[k][j]:1 else Xm[k][j]:Lx[k]**(j-1)
		)
	),

	Ym:zeromatrix(n,1),
	for k:1 thru n do
	(
		Ym[k][1]:Ly[k]
	),

	B:bfloat(invert(transpose(Xm).Xm).transpose(Xm).Ym),
	
	Px:0,
	for k:0 thru d do
	(
		Px : Px + B[k+1][1] * x**k
	),

	define(Pmc(x),Px),
	Pmc(x)
);



/* -----------------------------TRIGONOMETRIQUE -----------------------*/



/*
Fonction donnant une approximation d une serie de points par un polynome trigonometrique
Arguments:
Lx : liste des abscisses
Ly : liste des ordonnees, de mm taille que Lx
Resultat :
f(x) : le polyn6ome trigonométrique ajustant la serie de points. 
*/
interpFourier(Lx,Ly):=block
(
	kill(x,Px),
	n:length(Lx), /*pas de verification des erreurs pour linstant*/
	T:Lx[n]-Lx[1],
	w:2*%pi/T,

	/* on approxime les coefficients en approximant l integrale de la fonction */

	Px:bfloat((1/T)*sum((Ly[k]+Ly[k+1])*(Lx[k+1]-Lx[k])/2,k,1,n-1)), /* premier terme a0 */

	/*on ajoute mnt les termes de degre intermediaire*/
	for j:1 thru floor(n/2) do
	(
		aj:bfloat((1/T)*sum((Ly[k]+Ly[k+1])*(Lx[k+1]-Lx[k])*cos(w*j*Lx[k]),k,1,n-1)),
		bj:bfloat((1/T)*sum((Ly[k]+Ly[k+1])*(Lx[k+1]-Lx[k])*sin(w*j*Lx[k]),k,1,n-1)),
		Px:Px+aj*cos(w*j*x)+bj*sin(w*j*x)
	),
	define(f(x),Px),
	f(x)
);


/* ----------------- ERREUR QUADRATIQUE -------------------------*/



/*
Arguments :
u : premiere fonction
v : deuxieme fonction
a,b : les bornes de l'intégration, a < b
Resultat :
err : un réel, l'erreur quadratique entre f et g
*/
errQuadContinue(u,v,a,b):=block
(
	kill(x),
	integrate((u(x)-v(x))**2,x,a,b)
);
/*
Fonction donnant la forme discrète de l'erreur quadratique
Arguments :
u : premiere fonction
v : deuxieme fonction
Lx : la liste dea abscisses pour la comparaison
*/
errQuadDiscrete(u,v,Lx):=block
(
	kill(x),
	err : 0,
	for k : 1 thru length(Lx) do
	(
		x : Lx[k],
		err : err + bfloat((u(t)-v(t))**2)
	),
	kill(x),
	err
)$

